# 17 Effect

### 1. 前提

有一部分的逻辑若直接写到函数体中，会影响到组件的渲染，会产生“副作用”。例如，直接将修改state的逻辑写到组件中的话，会导致组件不断循环渲染，调用次数过多，内存溢出。Effect就是用来解决这个问题的。

（就是看逻辑是否与生成页面渲染之间是否有关系，存在的话，直接写；没有直接关系的话，则不能写。 ）

### 2. 关于`setState()`【函数组件】

当直接在函数体中调用setState时，就会触发“Too many re-renders（死循环）”这个错误。那这个错是怎么来的？

##### 2.1 `setState()`的执行流程

以`setCount()`为例，依赖dispatchSetData方法。它会先判断组件当前处于什么阶段。而函数体中的setState()属于渲染阶段，是不会去检查新旧state是否相同的。

- **渲染阶段** --> 不会检查state的新旧值是否相同；

- **非渲染阶段** --> 检查state的值是否相同

  - 值不同，则对组件进行重新渲染

  - 值相同，不对组件进行重新渲染 

  - - ❗️当值相同，在某些情况下，react会继续执行当前组件的渲染。但是这个渲染不会触发其子组件的渲染，也就是说，这次渲染不会产生实际的效果。
    - ❗️这种情况通常发生在当值第一次相同时。

### 3. `useEffect()`简介

是钩子函数，用于处理那些不能直接写在组件内部的代码，位置限于函数体中，需要一个函数作为第一个参数，第二个参数为依赖项数组（可有可无，但最好有）。第二个参数告诉React只有在依赖项中的某些值发生变化时才运行`useEffect()`。

作为参数的函数，将会在<u>组件渲染完毕后</u>执行。

##### 3.1 用法

```JavaScript
useEffect(() => { setCount(1) }, [依赖项数组]);    
```

可以将那些会产生副作用的代码编写到`useEffect()`的回调函数中，这样就可以避免这些代码影响到组件的渲染。

##### 3.2 依赖项

如果没有依赖项的话，`useEffect()`中的函数会在**每次渲染**结束后都执行。为了避免这种情况的发生，需要添加第二个参数——依赖项数组（指定effect的依赖项）。

1. 指定依赖项后，只有当effect发生变化时，`useEffect()`才会被调用
2. 通常情况下，Effect中所有使用到的局部变量都会设置为依赖项，但是<u>像`setState()`这样由钩子函数生成的函数不用被设置为依赖项</u>。（因为`useState()`会确保组件的每次渲染都会得到相同的`setState()`对象，不用考虑`setState()`会发生变化）
3. 如果依赖项为空数组，那只会在初始化时执行一次